<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tron Light Cycle Forward with Trails</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const horizon = canvas.height*0.3;
const gridSpacing = 50;

const player = {
  x: canvas.width/2,
  y: canvas.height*0.8,
  size: 15,
  color: 'cyan',
  trail: [],
  speed: 10, // movement per tap
  discs: 0
};

const bots = [];
const discs = [];
const flyingDiscs = [];

let botSpeed = 4;
let botTrailLength = 30;
let botSpawnTimer = 0;
let discSpawnTimer = 0;
let gridOffset = 0;
let score = 0;
let gameOver = false;

// Split-screen tap control
canvas.addEventListener('click', (e)=>{
  const x = e.clientX;
  if(x < canvas.width/2){
    player.x -= player.speed;
  } else {
    player.x += player.speed;
  }
  player.x = Math.max(10, Math.min(canvas.width-10, player.x));

  // Double-tap to throw disc
  const now = Date.now();
  if(now - lastTap < 300 && player.discs>0){
    flyingDiscs.push({x:player.x, y:player.y, size:10, color:'yellow'});
    player.discs--;
  }
  lastTap = now;
});

let lastTap = 0;

// Draw scrolling grid
function drawGrid() {
  ctx.strokeStyle='lime';
  ctx.lineWidth=1;
  gridOffset += 6;

  for(let i=0;i<canvas.height;i+=gridSpacing){
    const y = i + (gridOffset % gridSpacing);
    const scale = 1 - (y - horizon)/(canvas.height-horizon);
    if(scale<=0) continue;
    ctx.beginPath();
    const left = canvas.width*0.25*(1-scale);
    const right = canvas.width - canvas.width*0.25*(1-scale);
    ctx.moveTo(left,y);
    ctx.lineTo(right,y);
    ctx.stroke();
  }

  for(let i=0;i<canvas.width;i+=gridSpacing){
    ctx.beginPath();
    ctx.moveTo(i, canvas.height);
    ctx.lineTo(canvas.width/2, horizon);
    ctx.stroke();
  }
}

// Draw perimeter walls
function drawPerimeter() {
  ctx.fillStyle='red';
  ctx.fillRect(0,0,canvas.width,10);
  ctx.fillRect(0,canvas.height-10,canvas.width,10);
  ctx.fillRect(0,0,10,canvas.height);
  ctx.fillRect(canvas.width-10,0,10,canvas.height);
}

// Update player trail
function updatePlayerTrail(){
  player.trail.push({x:player.x,y:player.y});
  if(player.trail.length>50) player.trail.shift();
}

// Draw player with continuous light trail
function drawPlayer(){
  ctx.strokeStyle = 'cyan';
  ctx.lineWidth = player.size;
  ctx.beginPath();
  for(let i=0;i<player.trail.length;i++){
    const t = player.trail[i];
    if(i===0) ctx.moveTo(t.x, t.y);
    else ctx.lineTo(t.x, t.y);
  }
  ctx.stroke();

  ctx.fillStyle=player.color;
  ctx.fillRect(player.x-player.size/2,player.y-player.size/2,player.size,player.size);
}

// Spawn bots
function spawnBot(){
  const side = Math.random()<0.5 ? 10 : canvas.width-10;
  const y = horizon+20;
  bots.push({x:side, y:y, size:15, color:'magenta', trail:[]});
}

// Spawn discs
function spawnDisc(){
  const x = Math.random()*(canvas.width-20)+10;
  const y = horizon+20;
  discs.push({x,y,size:10,color:'yellow'});
}

// Update bots
function updateBots(){
  bots.forEach(bot=>{
    bot.y += 6;
    if(bot.x < player.x) bot.x += botSpeed*0.5;
    if(bot.x > player.x) bot.x -= botSpeed*0.5;

    bot.trail.push({x:bot.x,y:bot.y});
    if(bot.trail.length>botTrailLength) bot.trail.shift();
  });

  for(let i=bots.length-1;i>=0;i--){
    if(bots[i].y>canvas.height) bots.splice(i,1);
  }
}

// Draw bots with trails
function drawBots(){
  bots.forEach(bot=>{
    ctx.strokeStyle='magenta';
    ctx.lineWidth = bot.size;
    ctx.beginPath();
    for(let i=0;i<bot.trail.length;i++){
      const t=bot.trail[i];
      if(i===0) ctx.moveTo(t.x,t.y);
      else ctx.lineTo(t.x,t.y);
    }
    ctx.stroke();
    ctx.fillStyle=bot.color;
    ctx.fillRect(bot.x-bot.size/2, bot.y-bot.size/2, bot.size, bot.size);
  });
}

// Update discs
function updateDiscs(){
  discs.forEach(d=>d.y+=6);
  for(let i=discs.length-1;i>=0;i--){
    const dx = player.x - discs[i].x;
    const dy = player.y - discs[i].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist<player.size){
      player.discs++;
      discs.splice(i,1);
    } else if(discs[i].y>canvas.height) discs.splice(i,1);
  }

  flyingDiscs.forEach(fd=>fd.y-=15);
  for(let i=flyingDiscs.length-1;i>=0;i--){
    const fd=flyingDiscs[i];
    for(let j=bots.length-1;j>=0;j--){
      const dx = fd.x - bots[j].x;
      const dy = fd.y - bots[j].y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist<fd.size){
        bots.splice(j,1);
        flyingDiscs.splice(i,1);
        break;
      }
    }
    if(fd && fd.y<0) flyingDiscs.splice(i,1);
  }
}

// Draw discs
function drawDiscs(){
  discs.forEach(d=>{
    ctx.fillStyle=d.color;
    ctx.fillRect(d.x-d.size/2,d.y-d.size/2,d.size,d.size);
  });
  flyingDiscs.forEach(fd=>{
    ctx.fillStyle=fd.color;
    ctx.beginPath();
    ctx.arc(fd.x,fd.y,fd.size,0,Math.PI*2);
    ctx.fill();
  });
}

// Check collisions
function checkCollisions(){
  bots.forEach(bot=>{
    const dx = player.x - bot.x;
    const dy = player.y - bot.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if(dist < player.size) gameOver=true;
  });
}

// Draw score and discs
function drawScore(){
  ctx.fillStyle='white';
  ctx.font='24px Arial';
  ctx.fillText(`Score: ${score}  |  Discs: ${player.discs}`,20,40);
}

// Game loop
function gameLoop(){
  if(gameOver){
    ctx.fillStyle='white';
    ctx.font='48px Arial';
    ctx.fillText('GAME OVER',canvas.width/2-150,canvas.height/2);
    ctx.fillText(`Score: ${score}`,canvas.width/2-80,canvas.height/2+60);
    return;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  drawPerimeter();
  updatePlayerTrail();
  drawPlayer();

  if(botSpawnTimer<=0){spawnBot();botSpawnTimer=50;} else botSpawnTimer--;
  if(discSpawnTimer<=0){spawnDisc();discSpawnTimer=200;} else discSpawnTimer--;

  updateBots();
  drawBots();
  updateDiscs();
  drawDiscs();
  checkCollisions();
  drawScore();
  score++;

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>