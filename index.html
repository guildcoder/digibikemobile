<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>LightRunner — Tron Battle Royale</title>
<style>
  :root{--accent:#7CFFEA;--bg:#000;--hud:rgba(0,255,255,.08);}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--accent);font-family:Inter,system-ui,Roboto,monospace;}
  #wrap{position:relative;width:100%;height:100vh;overflow:hidden;background:linear-gradient(180deg,#000,#001);}
  canvas{display:block; width:100%; height:100%;}
  /* overlays */
  .centerCard{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.6);border:1px solid rgba(0,255,255,.06);padding:18px;border-radius:12px;text-align:center;min-width:260px}
  h1{margin:6px 0 6px 0;font-size:28px;letter-spacing:6px}
  p.small{font-size:13px;opacity:.9;margin:8px 0}
  .btn{display:inline-block;padding:12px 18px;border-radius:10px;border:1px solid rgba(0,255,255,.12);background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));color:var(--accent);font-weight:800;cursor:pointer;user-select:none}
  #hud{position:absolute;left:12px;top:12px;display:flex;gap:10px;align-items:center;z-index:10}
  .badge{background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:8px;border:1px solid rgba(0,255,255,.06);font-weight:700;font-size:14px}
  #controls{position:absolute;right:12px;bottom:12px;display:flex;flex-direction:column;gap:10px;z-index:10}
  .mini{font-size:12px;opacity:.9}
  #message{position:absolute;left:50%;top:12px;transform:translateX(-50%);z-index:11}
  #phaseClock{font-size:13px}
  #overlayInfo{position:absolute;left:50%;bottom:18%;transform:translateX(-50%);color:var(--accent);background:rgba(0,0,0,.3);padding:8px 12px;border-radius:10px;border:1px solid rgba(0,255,255,.06);z-index:9}
  @media (hover:none){
    h1{font-size:22px}
    .btn{padding:14px 20px}
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div class="badge" id="playersLeft">Players: 20</div>
    <div class="badge" id="phaseClock">Phase: —</div>
    <div class="badge" id="holdingBadge">Disc: No</div>
  </div>

  <!-- Controls -->
  <div id="controls">
    <div id="throwBtn" class="btn">THROW</div>
    <div id="restartBtn" class="btn mini">Restart</div>
  </div>

  <div id="message"></div>
  <div id="overlayInfo" class="mini">Tap left/right sides to steer. Throw to launch disc forward. Last alive wins.</div>

  <!-- Start Menu -->
  <div id="startMenu" class="centerCard">
    <h1>L I G H T R U N N E R</h1>
    <p class="small">Tron-style light cycles — Battle Royale twist. Tap left/right to steer. Pick up discs and throw to eliminate opponents. Watch the storm shrink!</p>
    <div style="margin-top:8px">
      <div id="btnPlay" class="btn">PLAY</div>
    </div>
    <p class="small" style="margin-top:10px">Players: 20 • Discs spawn sparsely • Storm phases: Shrink 30s → Hold 15s → Shrink 32s → Hold 15s (repeats)</p>
  </div>

  <!-- Game Over -->
  <div id="gameOver" class="centerCard" style="display:none">
    <h1 id="gameOverTitle">Game Over</h1>
    <p id="winnerLine" class="small">Winner: —</p>
    <div style="margin-top:8px">
      <div id="btnRestart" class="btn">Restart</div>
    </div>
  </div>
</div>

<script>
/* LightRunner — Full mini-game single file
   - World larger than viewport for camera follow
   - Storm phases: shrink30 -> hold15 -> shrink32 -> hold15 -> loop
   - Discs tuned to be sparse but enough for many players to pick some
   - Start menu and game over screens
*/

// CONFIG
const CONFIG = {
  initialPlayers: 20,
  cellSize: 10,           // grid cell pixel size
  trailThicknessCells: 1, // width of trail in cells
  speedCellsPerSecond: 12,// cells per second
  tickRate: 60,
  baseDiscRatio: 0.6,     // initial discs = players * baseDiscRatio
  discRespawnInterval: 4000, // ms - attempt respawn occasionally
  aiAggression: 0.03,
  world: {
    // world will be rectangular larger than viewport: width = max(viewport*2, 2000)
    minWidth: 2000,
    minHeight: 1200
  },
  storm: {
    // explicit phase sequence as requested:
    phases:[
      {type:'shrink', duration:30},  // shrink for 30s
      {type:'hold',   duration:15},  // hold for 15s
      {type:'shrink', duration:32},  // shrink for 32s
      {type:'hold',   duration:15}   // hold for 15s
      // sequence repeats
    ],
    finalInnerRadius: 40 // pixels — storm won't shrink below this circular radius
  },
  colors: {
    background: '#000000',
    stormEdge: 'rgba(255,20,100,0.26)',
    disc: '#FFD400',
    you: '#7CFFEA'
  }
};

// DOM & Canvas
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});
const wrap = document.getElementById('wrap');

// UI
const startMenu = document.getElementById('startMenu');
const gameOver = document.getElementById('gameOver');
const btnPlay = document.getElementById('btnPlay');
const btnRestart = document.getElementById('btnRestart');
const restartBtn = document.getElementById('restartBtn');
const throwBtn = document.getElementById('throwBtn');
const hudPlayers = document.getElementById('playersLeft');
const hudPhase = document.getElementById('phaseClock');
const hudHolding = document.getElementById('holdingBadge');
const messageEl = document.getElementById('message');
const winnerLine = document.getElementById('winnerLine');
const gameOverTitle = document.getElementById('gameOverTitle');

let vw=0, vh=0;
let worldW=0, worldH=0;
let gridCols=0, gridRows=0;
let cellSize = CONFIG.cellSize;
let occupancy; // Int32Array grid world occupancy: 0 empty, >0 player id
let players = [];
let discs = [];
let localPlayerId = 1;
let running = false;
let lastTime = 0;
let acc = 0;
let tickInterval = 1000/CONFIG.tickRate;
let camera = {x:0,y:0}; // world coords of top-left of viewport
let storm = {
  center:{x:0,y:0},
  radiusStart:0,
  radius:0,
  radiusTarget:0,
  phaseIndex:0,
  phaseStartTime:0,
  phaseTimeRemaining:0
};
let msgTimeout = null;

// UTIL
function rnd(min,max){return Math.random()*(max-min)+min;}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function pixelToCellWorld(x,y){ return {c: Math.floor(x/cellSize), r: Math.floor(y/cellSize)}; }
function cellToPixelWorld(c,r){ return {x: c*cellSize + cellSize/2, y: r*cellSize + cellSize/2}; }
function cellIndex(c,r){ return r*gridCols + c; }
function distance(a,b){ let dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
function randColor(i){
  const p = ['#7CFFEA','#FFD400','#FF6B6B','#8BE38B','#7A7CFF','#FF88D5','#FFA66B','#6FF0FF','#C9FF7A','#FFB07C'];
  return p[i % p.length];
}

// RESIZE + WORLD
function resize(){
  const rect = wrap.getBoundingClientRect();
  vw = Math.floor(rect.width);
  vh = Math.floor(rect.height);
  canvas.width = vw;
  canvas.height = vh;
  worldW = Math.max(CONFIG.world.minWidth, vw * 2);
  worldH = Math.max(CONFIG.world.minHeight, vh * 2);
  gridCols = Math.max(40, Math.floor(worldW / cellSize));
  gridRows = Math.max(30, Math.floor(worldH / cellSize));
  occupancy = new Int32Array(gridCols * gridRows);
  // center storm in world center initially
  storm.center.x = worldW/2;
  storm.center.y = worldH/2;
  // initial storm radius = large to cover world
  storm.radiusStart = Math.max(worldW, worldH);
  storm.radius = storm.radiusStart;
  storm.radiusTarget = storm.radiusStart * 0.75; // starting target (will be updated)
  // camera center around local player when running; otherwise center of world
  if(!running){
    camera.x = (worldW - vw) / 2;
    camera.y = (worldH - vh) / 2;
  }
}

// PLAYERS & TRAILS
function createPlayer(id, isHuman){
  const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  let dir = dirs[Math.floor(Math.random()*dirs.length)];
  let spawnPadding = 60;
  let p = {
    id,
    isHuman: !!isHuman,
    alive: true,
    dir,
    speedCellsPerSec: CONFIG.speedCellsPerSecond * (0.92 + Math.random()*0.16),
    trail: [], // cell indices
    pos: {x: rnd(spawnPadding, worldW - spawnPadding), y: rnd(spawnPadding, worldH - spawnPadding)},
    color: randColor(id),
    hasDisc: false,
    discCooldown: 0,
    ai: {turnCooldown: Math.random()*1, aggression: CONFIG.aiAggression + Math.random()*0.03},
    name: isHuman? 'You' : ('Bot'+id)
  };
  // align to grid
  let c = pixelToCellWorld(p.pos.x, p.pos.y);
  let cp = cellToPixelWorld(c.c, c.r);
  p.pos.x = cp.x; p.pos.y = cp.y;
  return p;
}

function markTrailCell(player, c, r){
  if(c<0 || r<0 || c>=gridCols || r>=gridRows) return;
  occupancy[cellIndex(c,r)] = player.id;
  player.trail.push(cellIndex(c,r));
}

function isCellOccupied(c,r){
  if(c<0 || r<0 || c>=gridCols || r>=gridRows) return true;
  return occupancy[cellIndex(c,r)] !== 0;
}

// DISC logic
function spawnInitialDiscs(){
  discs = [];
  const targetNum = Math.max(4, Math.floor(players.length * CONFIG.baseDiscRatio));
  for(let i=0;i<targetNum;i++) spawnOneDisc();
}
function spawnOneDisc(){
  let tries = 0;
  while(tries++ < 300){
    let px = rnd(40, worldW-40);
    let py = rnd(40, worldH-40);
    let cell = pixelToCellWorld(px, py);
    if(!isCellOccupied(cell.c, cell.r)){
      discs.push({
        id: 'disc_'+Date.now()+'_'+Math.floor(Math.random()*9999),
        x: px, y: py,
        radius: cellSize*0.9,
        picked: false,
        holder: null,
        inFlight: false,
        vx:0, vy:0,
        ownerId: null
      });
      return true;
    }
  }
  return false;
}

// RESET GAME
function resetGameSetup(){
  resize();
  occupancy.fill(0);
  players = [];
  for(let i=1;i<=CONFIG.initialPlayers;i++){
    players.push(createPlayer(i, i===localPlayerId));
  }
  // mark starting positions
  players.forEach(p=>{
    let c = pixelToCellWorld(p.pos.x, p.pos.y);
    markTrailCell(p, c.c, c.r);
  });
  spawnInitialDiscs();
  // storm phase init
  storm.phaseIndex = 0;
  storm.phaseStartTime = performance.now();
  storm.radiusStart = Math.max(worldW, worldH);
  // compute first target radius as a fraction
  storm.radiusTarget = Math.max(CONFIG.storm.finalInnerRadius, storm.radiusStart * 0.8);
  storm.radius = storm.radiusStart;
  running = true;
  hideStart();
  hideGameOver();
  flashMessage('');
  updateHud();
}

// HUD update
function updateHud(){
  hudPlayers.textContent = 'Players: ' + players.filter(p=>p.alive).length;
  let phase = stormPhase();
  if(phase){
    hudPhase.textContent = phase.type.toUpperCase() + ' • ' + Math.ceil(phase.remaining) + 's';
  } else hudPhase.textContent = '—';
  let local = players.find(p=>p.id===localPlayerId);
  hudHolding.textContent = 'Disc: ' + (local && local.hasDisc ? 'Yes' : 'No');
}

// STORM PHASES logic
function stormPhase(){
  // returns current phase object with remaining time in seconds
  if(!storm) return null;
  let phase = CONFIG.storm.phases[storm.phaseIndex % CONFIG.storm.phases.length];
  let now = performance.now();
  let elapsed = (now - storm.phaseStartTime) / 1000;
  let remaining = Math.max(0, phase.duration - elapsed);
  return {type:phase.type, duration:phase.duration, remaining, index:storm.phaseIndex};
}
function advanceStormPhase(){
  // move to next phase and set new targets
  storm.phaseIndex++;
  storm.phaseStartTime = performance.now();
  let nextPhase = CONFIG.storm.phases[storm.phaseIndex % CONFIG.storm.phases.length];
  // if next is shrink, compute a new radiusTarget smaller than current
  if(nextPhase.type === 'shrink'){
    // shrink proportionally: reduce to between 50% and 80% of current
    let reduction = rnd(0.48, 0.8); // variability
    storm.radiusStart = storm.radius; // starting point for shrink
    let minRadius = CONFIG.storm.finalInnerRadius;
    let candidate = Math.max(minRadius, storm.radius * reduction);
    // ensure target at least finalInnerRadius
    storm.radiusTarget = Math.max(minRadius, candidate);
  } else {
    // hold: keep radius constant
    storm.radiusStart = storm.radius;
    storm.radiusTarget = storm.radius;
  }
}

// MARK PLAYER KILL
function killPlayer(p, reason){
  if(!p.alive) return;
  p.alive = false;
  // if holding disc, drop it
  if(p.hasDisc){
    discs.push({
      id: 'drop_'+Date.now(),
      x: p.pos.x,
      y: p.pos.y,
      radius: cellSize*0.9,
      picked: false,
      holder: null,
      inFlight: false,
      vx:0, vy:0,
      ownerId: null
    });
    p.hasDisc = false;
  }
}

// THROW DISC
function throwDiscFromPlayer(p){
  if(!p.hasDisc || p.discCooldown > 0) return false;
  // find disc held
  let d = discs.find(x => x.holder === p.id && !x.inFlight);
  if(!d) return false;
  d.inFlight = true;
  d.ownerId = p.id;
  d.holder = null;
  d.picked = false;
  let speed = 700; // px/s
  d.vx = p.dir.x * speed;
  d.vy = p.dir.y * speed;
  p.hasDisc = false;
  p.discCooldown = 0.6;
  return true;
}

// AI helpers
function turnLeft(p){ let nx = -p.dir.y, ny = p.dir.x; p.dir.x = nx; p.dir.y = ny; }
function turnRight(p){ let nx = p.dir.y, ny = -p.dir.x; p.dir.x = nx; p.dir.y = ny; }
function steerTowards(p, tx, ty){
  let dx = tx - p.pos.x, dy = ty - p.pos.y;
  if(Math.abs(dx) > Math.abs(dy)){ p.dir.x = dx>0?1:-1; p.dir.y = 0; } else { p.dir.x = 0; p.dir.y = dy>0?1:-1; }
}
function aiBehavior(){
  players.forEach(p=>{
    if(!p.alive || p.isHuman) return;
    p.ai.turnCooldown -= 0.12;
    if(p.ai.turnCooldown <= 0){
      p.ai.turnCooldown = 0.12 + Math.random()*0.6;
      // bias away from storm edge if near
      let distC = distance(p.pos, storm.center);
      if(distC > storm.radius * 0.82){
        // steer inward
        steerTowards(p, storm.center.x, storm.center.y);
      } else if(Math.random() < 0.25 + p.ai.aggression*2){
        // pick random left/right
        if(Math.random() < 0.5) turnLeft(p); else turnRight(p);
      }
    }
    // attempt to go for discs if not holding
    if(!p.hasDisc && Math.random() < 0.12){
      let available = discs.filter(d=>!d.picked && !d.inFlight);
      if(available.length){
        // nearest
        let nearest = available.reduce((a,b) => (distance(p.pos,a) < distance(p.pos,b)) ? a : b);
        steerTowards(p, nearest.x, nearest.y);
      }
    }
    // attempt to throw occasionally if has disc
    if(p.hasDisc && Math.random() < 0.012 + p.ai.aggression) throwDiscFromPlayer(p);
  });
}

// GAME TICK
function tick(dt){
  if(!running) return;

  // Storm progression: update radius depending on phase
  let phaseObj = CONFIG.storm.phases[storm.phaseIndex % CONFIG.storm.phases.length];
  let now = performance.now();
  let elapsed = (now - storm.phaseStartTime)/1000;
  if(phaseObj.type === 'shrink'){
    // interpolate from start to target over phase duration
    let t = clamp(elapsed / phaseObj.duration, 0, 1);
    storm.radius = storm.radiusStart + (storm.radiusTarget - storm.radiusStart) * t;
    if(t >= 1 - 1e-6){
      // shrink finished, advance
      advanceStormPhase();
    }
  } else { // hold
    storm.radius = storm.radiusStart;
    if(elapsed >= phaseObj.duration - 1e-6) advanceStormPhase();
  }

  // Update players
  for(let p of players){
    if(!p.alive) continue;
    // AI decisions
    if(!p.isHuman){
      // small chance to perform advanced steer
      if(Math.random() < 0.02) aiBehavior();
    }
    // movement
    let movePixels = p.speedCellsPerSec * dt * cellSize;
    p.pos.x += p.dir.x * movePixels;
    p.pos.y += p.dir.y * movePixels;
    // snap to grid centers to keep trails consistent
    let cell = pixelToCellWorld(p.pos.x, p.pos.y);
    let cp = cellToPixelWorld(cell.c, cell.r);
    p.pos.x = cp.x; p.pos.y = cp.y;

    // out of world bounds -> kill
    if(p.pos.x < -20 || p.pos.x > worldW+20 || p.pos.y < -20 || p.pos.y > worldH+20){
      killPlayer(p, 'out');
      continue;
    }

    // storm kill
    if(distance(p.pos, storm.center) > storm.radius){
      killPlayer(p, 'storm');
      continue;
    }

    // trail collision: if occupying an already-occupied cell by another player's trail -> die
    if(isCellOccupied(cell.c, cell.r)){
      let ownerId = occupancy[cellIndex(cell.c, cell.r)];
      // allow if it's own last cell (to avoid instant self-collision) else die
      if(!(ownerId === p.id && p.trail[p.trail.length-1] === cellIndex(cell.c, cell.r))){
        killPlayer(p, 'trail');
        continue;
      }
    }

    // mark trail
    markTrailCell(p, cell.c, cell.r);

    // pickup disc if at same location and not holding one
    for(let d of discs){
      if(!d.picked && !p.hasDisc && !d.inFlight){
        if(distance({x:d.x,y:d.y}, p.pos) < cellSize*1.2){
          d.picked = true; d.holder = p.id; p.hasDisc = true;
        }
      }
    }
    // cooldown
    p.discCooldown = Math.max(0, p.discCooldown - dt);
  }

  // discs movement
  for(let d of discs){
    if(d.inFlight){
      d.x += d.vx * dt;
      d.y += d.vy * dt;
      // check hit with players
      for(let p of players){
        if(!p.alive) continue;
        if(p.id === d.ownerId) continue;
        if(distance(p.pos, d) < cellSize*1.2){
          killPlayer(p, 'hit');
          d.inFlight = false;
          d.picked = true;
          d.holder = null;
          break;
        }
      }
      // out of bounds?
      if(d.x < -50 || d.x > worldW+50 || d.y < -50 || d.y > worldH+50){
        d.inFlight = false;
        d.picked = false;
        d.holder = null;
      }
    } else if(d.picked && d.holder){
      let holder = players.find(p=>p.id===d.holder);
      if(holder && holder.alive){
        d.x = holder.pos.x + holder.dir.x * cellSize * 1.2;
        d.y = holder.pos.y + holder.dir.y * cellSize * 1.2;
      } else {
        d.picked = false; d.holder = null;
      }
    }
  }

  // Check for endgame
  let aliveList = players.filter(p=>p.alive);
  if(aliveList.length <= 1){
    running = false;
    if(aliveList.length === 1){
      const win = aliveList[0];
      showGameOver(win.id === localPlayerId ? 'You win! 🎉' : (win.name + ' wins'));
    } else {
      showGameOver('No winners');
    }
  }

  updateHud();
}

// RENDER
function render(){
  // clear viewport background
  ctx.fillStyle = CONFIG.colors.background;
  ctx.fillRect(0,0,vw,vh);

  // compute camera: follow local player (center behind)
  let local = players.find(p=>p.id===localPlayerId);
  if(local && local.alive){
    // center player in screen
    camera.x = clamp(local.pos.x - vw/2, 0, Math.max(0, worldW - vw));
    camera.y = clamp(local.pos.y - vh/2, 0, Math.max(0, worldH - vh));
  } else {
    // if dead or not found, slowly pan to center
    camera.x += ((worldW/2 - vw/2) - camera.x) * 0.05;
    camera.y += ((worldH/2 - vh/2) - camera.y) * 0.05;
  }

  // helper world->screen
  const sx = (wx)=> wx - camera.x;
  const sy = (wy)=> wy - camera.y;

  // draw arena background grid faint
  ctx.save();
  ctx.fillStyle = '#03030a';
  ctx.fillRect(0,0,vw,vh);
  // draw faint grid for world
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let gx = - (camera.x % (cellSize*4)); gx < vw; gx += cellSize*4){
    ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,vh); ctx.stroke();
  }
  for(let gy = - (camera.y % (cellSize*4)); gy < vh; gy += cellSize*4){
    ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(vw,gy); ctx.stroke();
  }
  ctx.restore();

  // draw trails (iterate occupancy might be large; instead draw from player.trail arrays)
  for(let p of players){
    if(p.trail.length === 0) continue;
    ctx.lineWidth = CONFIG.trailThicknessCells * cellSize + 1;
    ctx.strokeStyle = p.color;
    ctx.beginPath();
    let started=false;
    for(let idx of p.trail){
      let c = idx % gridCols;
      let r = Math.floor(idx / gridCols);
      let cp = cellToPixelWorld(c,r);
      let x = sx(cp.x), y = sy(cp.y);
      if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // draw discs
  for(let d of discs){
    if(d.picked && d.holder) continue;
    const screenX = sx(d.x), screenY = sy(d.y);
    // only draw if in viewport
    if(screenX < -40 || screenX > vw+40 || screenY < -40 || screenY > vh+40) continue;
    ctx.fillStyle = CONFIG.colors.disc;
    ctx.beginPath(); ctx.arc(screenX, screenY, d.radius, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(255,220,60,0.6)'; ctx.lineWidth = 2; ctx.stroke();
  }

  // draw players
  for(let p of players){
    if(!p.alive) continue;
    let x = sx(p.pos.x), y = sy(p.pos.y);
    // skip if not on screen to improve perf
    if(x < -40 || x > vw+40 || y < -40 || y > vh+40) continue;
    ctx.fillStyle = (p.id===localPlayerId ? CONFIG.colors.you : p.color);
    ctx.beginPath(); ctx.arc(x,y, cellSize*0.9, 0, Math.PI*2); ctx.fill();
    // forward eye
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(x + p.dir.x*cellSize*0.5, y + p.dir.y*cellSize*0.5, cellSize*0.28, 0, Math.PI*2); ctx.fill();
  }

  // draw storm overlay (circle centered in world)
  const stormScreenX = sx(storm.center.x), stormScreenY = sy(storm.center.y);
  ctx.save();
  // outer dim
  ctx.fillStyle = 'rgba(10,10,15,0.45)';
  ctx.beginPath();
  ctx.rect(0,0,vw,vh);
  ctx.arc(stormScreenX, stormScreenY, storm.radius, 0, Math.PI*2, true);
  ctx.fill('evenodd');
  // rim
  ctx.lineWidth = 6;
  ctx.strokeStyle = CONFIG.colors.stormEdge;
  ctx.beginPath(); ctx.arc(stormScreenX, stormScreenY, storm.radius, 0, Math.PI*2); ctx.stroke();
  ctx.restore();

  // HUD draws (already DOM)
}

// GAME LOOP
function loop(now){
  if(!lastTime) lastTime = now;
  let dtMs = now - lastTime;
  lastTime = now;
  acc += dtMs;
  while(acc >= tickInterval){
    tick(tickInterval/1000);
    acc -= tickInterval;
  }
  render();
  requestAnimationFrame(loop);
}

// INPUT
function setupInput(){
  function handleTap(x){
    if(!running) return;
    let p = players.find(pp=>pp.id===localPlayerId);
    if(!p || !p.alive) return;
    // determine screen center to choose left or right tap
    if(x < vw/2) turnLeft(p); else turnRight(p);
  }
  canvas.addEventListener('touchstart', function(e){
    e.preventDefault();
    let t = e.touches[0];
    handleTap(t.clientX);
  }, {passive:false});
  canvas.addEventListener('mousedown', function(e){
    handleTap(e.clientX);
  });

  window.addEventListener('keydown', function(e){
    if(!running){
      if(e.key === 'Enter' || e.key === ' '){ startGame(); }
      return;
    }
    let p = players.find(pp=>pp.id===localPlayerId);
    if(!p || !p.alive) return;
    if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') turnLeft(p);
    if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') turnRight(p);
    if(e.key === ' ' || e.key === 'Enter') throwDiscFromPlayer(p);
  });

  throwBtn.addEventListener('click', function(){
    let p = players.find(pp=>pp.id===localPlayerId);
    if(!p || !p.alive) return;
    if(!throwDiscFromPlayer(p)) flashMessage('No disc to throw');
    else flashMessage('Disc thrown');
  });
  restartBtn.addEventListener('click', resetToMenu);
}

// MESSAGES
function flashMessage(t, ms=900){
  messageEl.style.pointerEvents = 'none';
  messageEl.style.background = 'rgba(0,0,0,0.26)';
  messageEl.style.padding = '8px 10px';
  messageEl.style.borderRadius = '10px';
  messageEl.style.border = '1px solid rgba(0,255,255,.06)';
  messageEl.textContent = t;
  if(msgTimeout) clearTimeout(msgTimeout);
  msgTimeout = setTimeout(()=>{ messageEl.textContent=''; }, ms);
}

// START / STOP / UI
function showStart(){ startMenu.style.display = ''; }
function hideStart(){ startMenu.style.display = 'none'; }
function showGameOver(text){ gameOver.style.display = ''; gameOverTitle.textContent = 'Game Over'; winnerLine.textContent = text; }
function hideGameOver(){ gameOver.style.display = 'none'; }
function resetToMenu(){ running=false; showStart(); hideGameOver(); flashMessage(''); }

// Main game controls for start
function startGame(){
  resetGameSetup();
  // hide menus
  hideStart();
  hideGameOver();
  // begin loop if not started
  if(!lastTime) requestAnimationFrame(loop);
}

// Show a full-screen overlay winner screen
function showGameOver(winnerText){
  gameOverTitle.textContent = 'Game Over';
  winnerLine.textContent = winnerText;
  gameOver.style.display = '';
  // show restart button in HUD too
}

// Disc respawn logic periodically to keep disc availability
setInterval(()=>{
  if(!running) return;
  // ensure enough discs exist relative to players
  let alive = players.filter(p=>p.alive).length;
  let target = Math.max(4, Math.floor(alive * CONFIG.baseDiscRatio));
  let available = discs.filter(d=>!d.picked && !d.inFlight).length;
  if(available < target){
    spawnOneDisc();
  } else if(Math.random() < 0.08){
    // random occasional spawn
    spawnOneDisc();
  }
}, CONFIG.discRespawnInterval);

// Periodic AI nudge
setInterval(()=>{ if(running) aiBehavior(); }, 600);

// UI events
btnPlay.addEventListener('click', startGame);
btnRestart.addEventListener('click', startGame);
btnRestart.addEventListener('touchstart', ()=>startGame());
btnRestart.addEventListener('mousedown', ()=>startGame());
btnRestart.addEventListener('click', ()=>{}); // ensure clickable
btnRestart.addEventListener('keydown', ()=>{});
btnRestart.addEventListener('keypress', ()=>{});
btnRestart.style.cursor = 'pointer';
btnPlay.style.cursor = 'pointer';
btnRestart.style.userSelect = 'none';

// Restart button top-right (duplicate)
restartBtn.addEventListener('click', resetToMenu);

// initial setup
window.addEventListener('resize', ()=>{
  resize();
});
setupInput();
resize();
showStart();
requestAnimationFrame(loop);

</script>
</body>
</html>