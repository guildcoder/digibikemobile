<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LightRunner Minimal</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#000; }
  canvas { display:block; background:#000; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let vw, vh;
function resize() { vw = canvas.width = window.innerWidth; vh = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

// CONFIG
const CELL = 10;
const SPEED = 8; // cells per second
const NUM_PLAYERS = 5; // start small for testing

// GAME STATE
let gridW = 100;
let gridH = 60;
let occupancy = Array(gridW).fill(0).map(()=>Array(gridH).fill(0));
let players = [];
let localPlayer;

// UTIL
function rnd(a,b){return Math.random()*(b-a)+a;}
function cellToPx(c,r){return {x:c*CELL + CELL/2, y:r*CELL + CELL/2};}
function pxToCell(x,y){return {c:Math.floor(x/CELL), r:Math.floor(y/CELL)};}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

// CREATE PLAYERS
function createPlayer(id, human=false){
  let c = Math.floor(rnd(0, gridW));
  let r = Math.floor(rnd(0, gridH));
  let dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  let dir = dirs[Math.floor(Math.random()*dirs.length)];
  return {id, pos:{x:c*CELL, y:r*CELL}, dir, trail:[], alive:true, human};
}

// INIT
for(let i=0;i<NUM_PLAYERS;i++){
  let p = createPlayer(i+1, i===0);
  players.push(p);
  if(p.human) localPlayer = p;
}

// INPUT
function steer(player,left){
  if(!player.alive) return;
  let {x,y}=player.dir;
  player.dir = left ? {x:-y,y:x} : {x:y,y:-x};
}

canvas.addEventListener('mousedown', e=>{
  if(e.clientX < vw/2) steer(localPlayer,true);
  else steer(localPlayer,false);
});
canvas.addEventListener('touchstart', e=>{
  let t = e.touches[0];
  if(t.clientX < vw/2) steer(localPlayer,true);
  else steer(localPlayer,false);
});

// AI simple turn
function aiTurn(p){
  if(!p.alive || p.human) return;
  if(Math.random()<0.05) {
    steer(p,Math.random()<0.5);
  }
}

// GAME LOOP
let last = 0;
function loop(ts){
  if(!last) last=ts;
  let dt = (ts-last)/1000;
  last=ts;

  ctx.clearRect(0,0,vw,vh);

  // update players
  for(let p of players){
    if(!p.alive) continue;
    if(!p.human) aiTurn(p);
    // move
    p.pos.x += p.dir.x*SPEED*CELL*dt;
    p.pos.y += p.dir.y*SPEED*CELL*dt;

    // check collision with walls
    let c = Math.floor(p.pos.x/CELL);
    let r = Math.floor(p.pos.y/CELL);
    if(c<0||c>=gridW||r<0||r>=gridH||occupancy[c][r]){
      p.alive=false;
      continue;
    }
    occupancy[c][r]=p.id;
    p.trail.push({x:p.pos.x,y:p.pos.y});
  }

  // CAMERA
  let camX = localPlayer.pos.x - vw/2;
  let camY = localPlayer.pos.y - vh/2;

  // DRAW
  for(let p of players){
    ctx.strokeStyle = p.human?'#0FF':'#F00';
    ctx.beginPath();
    for(let i=0;i<p.trail.length;i++){
      let t=p.trail[i];
      if(i===0) ctx.moveTo(t.x-camX,t.y-camY);
      else ctx.lineTo(t.x-camX,t.y-camY);
    }
    ctx.stroke();
    if(p.alive){
      ctx.fillStyle=p.human?'#0FF':'#F00';
      ctx.beginPath();
      ctx.arc(p.pos.x-camX,p.pos.y-camY,CELL/2,0,Math.PI*2);
      ctx.fill();
    }
  }

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>