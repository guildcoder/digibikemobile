<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LIGHTRUNNER</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = {
  x: canvas.width / 2,
  y: canvas.height * 0.7,
  size: 15,
  color: 'cyan',
  trail: [],
  speed: 6,
  direction: { x: 0, y: 0 }
};

let bots = [];
let botSpeed = 4;
let botTrailLength = 20;
let score = 0;
let gameOver = false;
const perimeter = 50; // red walls thickness

// Input
let keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

// Helpers
function drawGrid() {
  // Ground grid (tilted perspective)
  ctx.strokeStyle = 'lime';
  ctx.lineWidth = 1;
  const horizon = canvas.height * 0.4;

  // vertical lines converging
  for (let i=0; i<canvas.width; i+=50){
    ctx.beginPath();
    ctx.moveTo(i, canvas.height);
    ctx.lineTo(canvas.width/2 + (i-canvas.width/2)*0.3, horizon);
    ctx.stroke();
  }

  // horizontal lines
  for (let j=0; j<canvas.height-horizon; j+=50){
    const y = canvas.height - j;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  // Vertical sky lines
  ctx.strokeStyle = '#0ff';
  for (let i=0;i<canvas.width;i+=100){
    ctx.beginPath();
    ctx.moveTo(i,0);
    ctx.lineTo(i,horizon);
    ctx.stroke();
  }
}

function drawPerimeter() {
  ctx.fillStyle = 'red';
  ctx.fillRect(0,0,canvas.width,perimeter); // top
  ctx.fillRect(0,canvas.height-perimeter,canvas.width,perimeter); // bottom
  ctx.fillRect(0,0,perimeter,canvas.height); // left
  ctx.fillRect(canvas.width-perimeter,0,perimeter,canvas.height); // right
}

function updatePlayer() {
  if (keys['ArrowUp']) player.y -= player.speed;
  if (keys['ArrowDown']) player.y += player.speed;
  if (keys['ArrowLeft']) player.x -= player.speed;
  if (keys['ArrowRight']) player.x += player.speed;

  // Keep inside perimeter
  player.x = Math.max(perimeter, Math.min(canvas.width - perimeter, player.x));
  player.y = Math.max(perimeter, Math.min(canvas.height - perimeter, player.y));

  // Add to trail
  player.trail.push({x:player.x, y:player.y});
  if (player.trail.length > 50) player.trail.shift();
}

function drawPlayer() {
  // trail
  for (let i=0;i<player.trail.length;i++){
    const t = player.trail[i];
    ctx.fillStyle = `rgba(0,255,255,${i/player.trail.length})`;
    ctx.fillRect(t.x-5, t.y-5, player.size, player.size);
  }
  // bike
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x-player.size/2, player.y-player.size/2, player.size, player.size);
}

function spawnBot() {
  const side = Math.floor(Math.random()*4);
  let x,y;
  if(side===0){x=perimeter+10; y=Math.random()*(canvas.height-2*perimeter)+perimeter;}
  if(side===1){x=canvas.width-perimeter-10; y=Math.random()*(canvas.height-2*perimeter)+perimeter;}
  if(side===2){y=perimeter+10; x=Math.random()*(canvas.width-2*perimeter)+perimeter;}
  if(side===3){y=canvas.height-perimeter-10; x=Math.random()*(canvas.width-2*perimeter)+perimeter;}
  bots.push({x,y,size:15,color:'magenta',trail:[],target:player});
}

function updateBots() {
  bots.forEach(bot=>{
    // simple AI: move toward player
    const dx = bot.target.x - bot.x;
    const dy = bot.target.y - bot.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    bot.x += (dx/dist)*botSpeed;
    bot.y += (dy/dist)*botSpeed;

    // trail
    bot.trail.push({x:bot.x, y:bot.y});
    if(bot.trail.length>botTrailLength) bot.trail.shift();
  });

  // remove bots that are past the player
  bots = bots.filter(bot => bot.y < canvas.height);
}

function drawBots() {
  bots.forEach(bot=>{
    bot.trail.forEach((t,i)=>{
      ctx.fillStyle = `rgba(255,0,255,${i/bot.trail.length})`;
      ctx.fillRect(t.x-5,t.y-5,bot.size,bot.size);
    });
    ctx.fillStyle = bot.color;
    ctx.fillRect(bot.x-bot.size/2, bot.y-bot.size/2, bot.size, bot.size);
  });
}

function checkCollisions() {
  bots.forEach(bot=>{
    const dx = player.x - bot.x;
    const dy = player.y - bot.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < player.size){
      gameOver = true;
    }
  });
}

function drawScore() {
  ctx.fillStyle='white';
  ctx.font='24px Arial';
  ctx.fillText(`Score: ${score}`,20,40);
}

function gameLoop() {
  if(gameOver){
    ctx.fillStyle='white';
    ctx.font='48px Arial';
    ctx.fillText('GAME OVER', canvas.width/2-150, canvas.height/2);
    ctx.fillText(`Score: ${score}`, canvas.width/2-80, canvas.height/2+60);
    return;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  drawPerimeter();
  updatePlayer();
  drawPlayer();
  if(Math.random()<0.02) spawnBot();
  updateBots();
  drawBots();
  checkCollisions();
  drawScore();
  score++;

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>